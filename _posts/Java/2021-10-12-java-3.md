---
title: "JVM(Java Virtual Machine) - 2"
excerpt: "자바 가상 머신 JVM"
classes: wide
categories:
 - java
tags:
 - java
 - jvm
last_modified_at: 2021-10-12
---

![1](https://user-images.githubusercontent.com/26619776/136971420-0e379df9-ac0a-429f-8ecd-77f4a15fc4f7.png)

### **자바 컴파일러**

자바 소스코드(.java)를 바이트 코드(.class)로 변환시켜줌

### Class Loader (**클래스 로더)**

JVM은 런타임시에 처음으로 클래스를 참조할 때 해당 클래스를 로드하고 메모리 영역에 배치시킴. 

이 동적 로드를 담당하는 부분이 바로 클래스 로더

+) (컴파일러 역할) 자바는 동적코드, 컴파일 타임이 아니라 런타임에 참조한다. 즉, 클래스를 처음으로 참조할 때, 해당 클래스를 로드하고 링크

### **Runtime Data Areas**

JVM이 운영체제 위에서 실행되면서 할당받는 메모리 영역임

총 5가지 영역으로 나누어짐 : PC 레지스터, JVM 스택, 네이티브 메서드 스택, 힙, 메서드 영역

(이 중에 힙과 메서드 영역은 모든 스레드가 공유해서 사용함)

- Method Area(**메서드 영역)**
    - JVM이 시작될 때 생성되고, JVM이 읽은 각각의 클래스와 인터페이스에 대한 런타임 상수 풀, 필드 및 메서드 코드, 정적 변수, 메서드의 바이트 코드 등을 보관함
    - 클래스 멤버 변수의 이름, 데이터 타입, 접근 제어자 정보, 필드 정보, 메서드 이름, 리턴 타입, 파라미터 등이 생성되는 영역
- Heap Area(**힙** 영역)
    - 런타임에 동적으로 할당되는 데이터가 저장되는 영역
    - new 키워드로 생성된 객체와 배열이 생성되는 영역
    - 메서드 영역에 로드된 클래스만 생서이 가능하고 Carbage Collector가 참조되지 않는 메모리를 확인하고 제거하는 영역
- Stack Area(**스택 영역)**
    - 지역변수, 매개변수, 메서드 정보, 임시 데이터 등을 저장
- PC Register( **PC 레지스터)**
    - Thread가 생성될 때마다 생성되는 영역으로 Program Counter로 현재 쓰레드가 실행되는 부분의 주소와 명령을 저장하고 있는 영역
- Native Method Stack(**네이티브 메서드 스택)**
    - 실제 실행할 수 있는 기계어로 작성된 프로그램을 실행시키는 영역
    - 자바 외 언어로 작성된 네이티브 코드를 위한 메모리 영역
    - 보통 C/C++ 등의 코드를 수행하기 위한 스택(JNI)

![2](https://user-images.githubusercontent.com/26619776/136971484-b89d14bb-7a8b-4b7a-aa43-6ef970cbbb29.png)

### Excution Engine(실행 엔진)

클래스를 실행시키는 역할

자바 바이트 코드는 기계가 바로 수행할 수 있는 언어보다는 비교적 인간이 보기 편한 형태로 기술 된 것이다. 그래서 실행 엔진은 이와 같은 바이트코드를 실제로 JVM 내부에서 기계가 실행할 수 있는 형태로 변경한다.

> 이때 사용되는 2가지 방식
> 

### Interpreter(인터프리터)

바이트 코드 명령어를 하나씩 읽어서 해석하고 실행합니다. 하나하나의 실행은 빠르나, 전체적인 실행 속도가 느리다는 단점을 가집니다.

### JIT(Just - In - Time)

인터프리터 방식의 단점을 보완하기 위해 되입된 JIT 컴파일러. 인터프리터 방식으로 실행하다가 적절한 시점에 바이트코드 전체를 컴파일하여 네이티브 코드(바이너리 코드)로 변경하고, 이후에는 더 이상 인터프리팅 하지 않고 네이티브 코드로 직접 실행하는 방식이다. 네이티브 코드는 캐시에 보관하기 때문에 한 번 컴파일된 코드는 빠르게 수행하게 된다. 

물론 JIT 컴파일러가 컴파일하는 과정은 바이트 코드를 인터프리팅하는 것 보다 훨씬 오래걸리므로 한 번만 실행되는 코드라면 컴파일하지 않고 인터프리팅 하는 것이 유리하다. 따라서 JIT 컴파일러를 사용하는 JVM들은 내부적으로 해당 메서드가 얼마나 자주 수행되는지 체크하고, 일정 정도를 넘을 때에만 컴파일을 수행한다.

### Garbage Collector

GC를 수행하는 모듈(쓰레드)이 있다.
